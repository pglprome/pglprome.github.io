<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TCP Unix 网络抓包分析 示例</title>
      <link href="/2023/01/05/tcpdump/"/>
      <url>/2023/01/05/tcpdump/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-QNX内部Virtio-net-抓包分析"><a href="#Android-QNX内部Virtio-net-抓包分析" class="headerlink" title="Android QNX内部Virtio net 抓包分析"></a>Android QNX内部Virtio net 抓包分析</h1><p>工具：tcpdump + wireshark</p><p>背景：负责项目出现Android QNX内部网络丢包问题</p><p>解决思路：通过抓包进一步分析root cause，需要通过tcpdump抓两个系统的网络包，并通过wireshark分析</p><p>步骤</p><h2 id="1-tcpdum抓包"><a href="#1-tcpdum抓包" class="headerlink" title="1. tcpdum抓包"></a>1. tcpdum抓包</h2><p>通过ifconfig确定两个系统Virtio-Ethernet对应的网卡</p><p>得出Android的网卡是eth0， QNX的网卡是vp0</p><p>应用的服务端跑在QNX,端口号为49598，所以抓包命令为</p><pre><code>QNX侧:tcpdump -v -i vp0 port 49598 -c 400000 -w /blackbox/tcpdump49598.pcapAndroid侧:tcpdump -i eth0 -vvn -w tcpdump_android.pcap</code></pre><p>后续通过tcpdump获得的pcap文件，导入wireshark继续分析</p><p>附上tcpdump常用参数:</p><pre><code>1、指定网卡。tcpdump -i eth02、指定iptcpdump -i eth0 ip host 172.168.1.13、指定端口tcpdump -i eth0 port 804、指定协议tcpdump -i eth0 udp/tcp5、指定源和目的tcpdump -i eth0 src/dst host 172.168.1.16、写入指定的文件中tcpdump -i eth0 ip host 172.168.1.1 -w/opt/wenjian,cap7、将抓包信息打印到前台。tcpdump -A -i etho ip host 172.168.1.1 -vvn8、写入1000个包到文件中tcpdump -i eth0 ip host 172.168.1.1 -c 1000 -w /opt/wenjian,cap9、环路抓包tcpdump -i ol</code></pre><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># tcpdump -v -i vp0 port 49598 -c 400000 -w blackbox/tcpdump49598.pcap</span>tcpdump: listening on vp0, link-type EN10MB <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>, capture size 262144 bytes547 packets captured9576 packets received by filter0 packets dropped by kernel<span class="token comment" spellcheck="true"># ls /blackbox/tcpdump49598.pcap  </span>/blackbox/tcpdump49598.pcap<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-用wireshark分析pcap文件"><a href="#2-用wireshark分析pcap文件" class="headerlink" title="2. 用wireshark分析pcap文件"></a>2. 用wireshark分析pcap文件</h2><p>用wireshark打开，大概是这样的界面，由于tcpdump已经过滤了port 49598的数据，所以打开不需要过滤就能看到192.068.1.1(server)和192.168.1.3(client)之间在49598上通信的报文</p><p><img src="https://pic.imgdb.cn/item/63b6e482be43e0d30e98b7b7.jpg" alt></p><p>但是报文那么多，我们怎么知道哪条报文是我们需要找的?</p><p>为此我</p><h3 id="1-修改了servcer端的代码，减少了我不想抓的报文"><a href="#1-修改了servcer端的代码，减少了我不想抓的报文" class="headerlink" title="1. 修改了servcer端的代码，减少了我不想抓的报文"></a>1. 修改了servcer端的代码，减少了我不想抓的报文</h3><h3 id="2-通过应用的log打印，获取发送到socket的大致时间"><a href="#2-通过应用的log打印，获取发送到socket的大致时间" class="headerlink" title="2. 通过应用的log打印，获取发送到socket的大致时间"></a>2. 通过应用的log打印，获取发送到socket的大致时间</h3><p><img src="https://pic.imgdb.cn/item/63b6e5f3be43e0d30e9ba1c8.jpg" alt><br>通过log我们能够定位发送报文的时间大概是Jan 05 01:58:34.054</p><h3 id="3-通过wireshar过滤掉192-168-1-3-gt-192-068-1-1的报文，只保留192-068-1-1-gt-192-168-1-3的报文"><a href="#3-通过wireshar过滤掉192-168-1-3-gt-192-068-1-1的报文，只保留192-068-1-1-gt-192-168-1-3的报文" class="headerlink" title="3. 通过wireshar过滤掉192.168.1.3 -&gt; 192.068.1.1的报文，只保留192.068.1.1 -&gt; 192.168.1.3的报文"></a>3. 通过wireshar过滤掉192.168.1.3 -&gt; 192.068.1.1的报文，只保留192.068.1.1 -&gt; 192.168.1.3的报文</h3><p>通过ip.src == 192.168.1.1只显示192.068.1.1 -&gt; 192.168.1.3的报文</p><p>附上wireshark常用过滤参数:<br>注: 过滤表达式可通过&amp;&amp;, |, !, ^^等逻辑符号进行组合</p><pre class="line-numbers language-bash"><code class="language-bash">1. 针对ip的过滤对源地址进行过滤ip.src <span class="token operator">==</span> 192.168.0.1对目的地址进行过滤ip.dst <span class="token operator">==</span> 192.168.0.1对源地址或者目的地址进行过滤ip.addr <span class="token operator">==</span> 192.168.0.1如果想排除以上的数据包，只需要将其用括号囊括，然后使用 <span class="token string">"!"</span> 即可<span class="token operator">!</span><span class="token punctuation">(</span>ip.addr <span class="token operator">==</span> 192.168.0.1<span class="token punctuation">)</span>2. 针对协议的过滤获某种协议的数据包，表达式很简单仅仅需要把协议的名字输入即可http注意：是否区分大小写？答：区分，只能为小写捕获多种协议的数据包http or telnet排除某种协议的数据包not arp   或者   <span class="token operator">!</span>tcp3. 针对端口的过滤（视传输协议而定）捕获某一端口的数据包（以tcp协议为例）tcp.port <span class="token operator">==</span> 80捕获多端口的数据包，可以使用and来连接，下面是捕获高于某端口的表达式（以udp协议为例）udp.port <span class="token operator">>=</span> 20484. 针对长度和内容的过滤针对长度的过虑（这里的长度指定的是数据段的长度）udp.length <span class="token operator">&lt;</span> 20   http.content_length <span class="token operator">&lt;=</span>30针对uri 内容的过滤http.request.uri matches <span class="token string">"user"</span> <span class="token punctuation">(</span>请求的uri中包含“user”关键字的<span class="token punctuation">)</span>注意：matches 后的关键字是不区分大小写的！http.request.uri contains <span class="token string">"User"</span> <span class="token punctuation">(</span>请求的uri中包含“user”关键字的<span class="token punctuation">)</span>注意：contains 后的关键字是区分大小写的！5. 针对http请求的一些过滤实例。过滤出请求地址中包含“user”的请求，不包括域名；http.request.uri contains <span class="token string">"User"</span>精确过滤域名http.host<span class="token operator">==</span>baidu.com模糊过滤域名http.host contains <span class="token string">"baidu"</span>过滤请求的content_type类型http.content_type <span class="token operator">==</span><span class="token string">"text/html"</span>过滤http请求方法http.request.method<span class="token operator">==</span><span class="token string">"POST"</span>过滤tcp端口tcp.port<span class="token operator">==</span>80http <span class="token operator">&amp;&amp;</span> tcp.port<span class="token operator">==</span>80 or tcp.port<span class="token operator">==</span>5566过滤http响应状态码http.response.code<span class="token operator">==</span>302过滤含有指定cookie的http数据包http.cookie contains <span class="token string">"userid"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-由于我只想知道业务报文，不关心握手报文，ACK报文以及心跳报文，所以我们可通过PSH找到有data的报文"><a href="#4-由于我只想知道业务报文，不关心握手报文，ACK报文以及心跳报文，所以我们可通过PSH找到有data的报文" class="headerlink" title="4. 由于我只想知道业务报文，不关心握手报文，ACK报文以及心跳报文，所以我们可通过PSH找到有data的报文"></a>4. 由于我只想知道业务报文，不关心握手报文，ACK报文以及心跳报文，所以我们可通过PSH找到有data的报文</h3><p>在TCP层，有个FLAGS字段，这个字段有以下几个标识：SYN, FIN, ACK, PSH, RST, URG.</p><p>通过找到PSH的字段，就是我们需要的业务报文</p><p>参考: <a href="https://zhuanlan.zhihu.com/p/439614017" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/439614017</a><br>附上TCP层，FLAGS字段含义:</p><pre><code>SYN表示建立连接，FIN表示关闭连接，ACK表示响应，PSH表示有 DATA数据传输，RST表示连接重置。其中，ACK是可能与SYN，FIN等同时使用的，比如SYN和ACK可能同时为1，它表示的就是建立连接之后的响应，如果只是单个的一个SYN，它表示的只是建立连接。TCP的几次握手就是通过这样的ACK表现出来的。但SYN与FIN是不会同时为1的，因为前者表示的是建立连接，而后者表示的是断开连接。RST一般是在FIN之后才会出现为1的情况，表示的是连接重置。一般地，当出现FIN包或RST包时，我们便认为客户端与服务器端断开了连接；而当出现SYN和SYN＋ACK包时，我们认为客户端与服务器建立了一个连接。PSH为1的情况，一般只出现在 DATA内容不为0的包中，也就是说PSH为1表示的是有真正的TCP数据包内容被传递。TCP的连接建立和连接关闭，都是通过请求－响应的模式完成的。</code></pre><h3 id="5-通过代码定义的header找到精确的报文"><a href="#5-通过代码定义的header找到精确的报文" class="headerlink" title="5. 通过代码定义的header找到精确的报文"></a>5. 通过代码定义的header找到精确的报文</h3><p>由于我们的报文是通过flatbuffer序列化后的，且不是string类型，故wireshark只能看到序列化后的十六进制数据，看不到内容，所以需要想点办法通过报文中的data定位我们需要找的数据</p><p>分析发送代码:</p><pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">bool</span> MessagingManager<span class="token operator">::</span><span class="token function">sendMessage</span><span class="token punctuation">(</span>nio<span class="token operator">::</span>messaging<span class="token operator">::</span>TxMessageIds messageId<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> payloadLength<span class="token punctuation">,</span> uint8_t <span class="token operator">*</span>payload<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>mSendMutex<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//Prevent out of order messages from being sent from multiple threads</span>    <span class="token keyword">bool</span> send_valid <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    uint8_t buf_header<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    uint32_t id <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>uint32_t<span class="token operator">></span><span class="token punctuation">(</span>messageId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* not good practice : network should use big-endian */</span>    buf_header<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> id<span class="token operator">&amp;</span><span class="token number">0xFF</span><span class="token punctuation">;</span>    buf_header<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>id<span class="token operator">>></span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xFF</span><span class="token punctuation">;</span>    buf_header<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>id<span class="token operator">>></span><span class="token number">16</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xFF</span><span class="token punctuation">;</span>    buf_header<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>id<span class="token operator">>></span><span class="token number">24</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xFF</span><span class="token punctuation">;</span>    buf_header<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> payloadLength<span class="token operator">&amp;</span><span class="token number">0xFF</span><span class="token punctuation">;</span>    buf_header<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>payloadLength<span class="token operator">>></span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xFF</span><span class="token punctuation">;</span>    buf_header<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>payloadLength<span class="token operator">>></span><span class="token number">16</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xFF</span><span class="token punctuation">;</span>    buf_header<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>payloadLength<span class="token operator">>></span><span class="token number">24</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xFF</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>MAX_CONNECTIONS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mConnections<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">isValid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">struct</span> iovec iov<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            iov<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>iov_base <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>buf_header<span class="token punctuation">;</span>            iov<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>iov_len  <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf_header<span class="token punctuation">)</span><span class="token punctuation">;</span>            iov<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>iov_base <span class="token operator">=</span> payload<span class="token punctuation">;</span>            iov<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>iov_len <span class="token operator">=</span> payloadLength<span class="token punctuation">;</span>            mTcpServer<span class="token operator">-</span><span class="token operator">></span><span class="token function">SendV</span><span class="token punctuation">(</span>mConnections<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getSocket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> iov<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            send_valid <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">false</span> <span class="token operator">==</span> send_valid<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        NioLog<span class="token operator">::</span><span class="token function">warning</span><span class="token punctuation">(</span><span class="token string">"MessagingManager: {}  Can't send MessageId {}"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">,</span> messageId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> send_valid<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">bool</span> CTCPServer<span class="token operator">::</span><span class="token function">SendV</span><span class="token punctuation">(</span><span class="token keyword">const</span> Socket socket<span class="token punctuation">,</span> <span class="token keyword">struct</span> iovec <span class="token operator">*</span>iov<span class="token punctuation">,</span> <span class="token keyword">int</span> iovcnt<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">int</span> iResult <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   iResult <span class="token operator">=</span> <span class="token function">writev</span><span class="token punctuation">(</span>socket<span class="token punctuation">,</span> iov<span class="token punctuation">,</span> iovcnt<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>iResult <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      NioLog<span class="token operator">::</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"[TCPServer][Error] ret {} IOV writing to socket : {} ({})"</span><span class="token punctuation">,</span> iResult<span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，报文是由两部分组成，第一部分是buf_header，第二部分是序列化后的payload。</p><p>buf_header是由8 bytes组成（uint8_t buf_header[8]），messageId是一个五位数的十进制整数，最大不超过2^17。</p><p>buf_header[0]是messageId二进制的0-7位（0xFF即 1111 1111）。<br>buf_header[1]是messageId二进制的8-15位。<br>buf_header[2]是messageId二进制的16-23位。<br>buf_header[3]是messageId二进制的24-31位。</p><p>分析到这里就比较简单了，我查了我想抓的报文的messageId是57275<br>转换成十六进制是0xDFBB,二进制为1101 1111 1011 1011。<br>(注: 一位十六进制是2^4, 即四位二进制，故四位二进制正好表达一位十六进制)</p><p>故这个messageId总共只有16位二进制，故buf_header[0]为BB，buf_header[1]为DF，故buf_header[2]和buf_header[3]均为0.</p><p>我们只要找到报文的data开头是BB DF 00 00 的报文，即是我们需要的报文。<br>到这一步，就很轻易的找到了</p><p>如下图所示，即为我们需要找的报文<br><img src="https://pic.imgdb.cn/item/63b6f0b3be43e0d30eb0fb93.jpg" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>POSIX 定时器_QNX实现</title>
      <link href="/2022/12/21/posix-timer/"/>
      <url>/2022/12/21/posix-timer/</url>
      
        <content type="html"><![CDATA[<h1 id="一、POSXI接口定时器-QNX实现"><a href="#一、POSXI接口定时器-QNX实现" class="headerlink" title="一、POSXI接口定时器_QNX实现"></a>一、POSXI接口定时器_QNX实现</h1><p>设置定时器，并设置通知方式，内核以signal的方式通知到时</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"Handler.hpp"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;ctime></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span><span class="token macro property">#<span class="token directive keyword">ifdef</span> __QNX__</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/siginfo.h></span></span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token keyword">namespace</span> nio<span class="token punctuation">{</span>    HandlerQueue<span class="token operator">::</span><span class="token function">HandlerQueue</span><span class="token punctuation">(</span>DispatchQueue <span class="token operator">&amp;</span>dispatchQueue<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">mDispatchQueue</span><span class="token punctuation">(</span>dispatchQueue<span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    HandlerQueue<span class="token operator">::</span><span class="token operator">~</span><span class="token function">HandlerQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> HandlerQueue<span class="token operator">::</span><span class="token function">pushFunctionDelayed</span><span class="token punctuation">(</span><span class="token keyword">int</span> msgId<span class="token punctuation">,</span> TimerTriggeredFunction <span class="token operator">&amp;&amp;</span>triggeredFunction<span class="token punctuation">,</span> <span class="token keyword">long</span> delayMs<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Message <span class="token operator">*</span>msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Message</span><span class="token punctuation">(</span>msgId<span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>triggeredFunction<span class="token punctuation">)</span><span class="token punctuation">,</span> mDispatchQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         设置计时结束后，系统的通知方式，这里设置的是后台另启动一个线程，通过信号方式通知，并调用onTriggered方法，同时将msg指针传给onTriggered。        SIGEV_THREAD_INIT (eventp, func, val, attributes)        用线程函数（func）和属性结构（attribute）填充eventp。执行线程时，将val中的值传递给func中的函数。        **/</span>        <span class="token function">SIGEV_THREAD_INIT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg<span class="token operator">-</span><span class="token operator">></span>mEvent<span class="token punctuation">,</span> HandlerQueue<span class="token operator">::</span>onTriggered<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">ifdef</span> __QNX__</span>        itimerspec itime<span class="token punctuation">;</span>        itime<span class="token punctuation">.</span>it_value<span class="token punctuation">.</span>tv_sec <span class="token operator">=</span> delayMs <span class="token operator">/</span> <span class="token number">1000</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//设置秒单位的计时</span>        itime<span class="token punctuation">.</span>it_value<span class="token punctuation">.</span>tv_nsec <span class="token operator">=</span> <span class="token number">1000000</span> <span class="token operator">*</span> <span class="token punctuation">(</span>delayMs <span class="token operator">%</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置纳秒单位的计时</span>        itime<span class="token punctuation">.</span>it_interval<span class="token punctuation">.</span>tv_sec <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//设置秒单位的计时器间隔</span>        itime<span class="token punctuation">.</span>it_interval<span class="token punctuation">.</span>tv_nsec <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置纳秒单位的计时器间隔</span>        <span class="token comment" spellcheck="true">/**         * #include &lt;time.h>           #include &lt;sys/siginfo.h>            int timer_create (clockid_t clock_id,                        struct sigevent *event,                        timer_t *timerid);                        该clock_id参数告诉timer_create（）函数它要创建这个定时器时间基准。这是POSIX的事– POSIX表示在不同的平台上可以有多个时基，但是每个平台都必须至少支持CLOCK_REALTIME时基。在Neutrino下，有 三个时基可供选择：                        CLOCK_REALTIME重点是这个；                        CLOCK_SOFTTIME                        CLOCK_MONOTONIC         * **/</span>        <span class="token function">timer_create</span><span class="token punctuation">(</span>CLOCK_MONOTONIC<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token operator">-</span><span class="token operator">></span>mEvent<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token operator">-</span><span class="token operator">></span>mTimerId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**#include &lt;time.h>            int timer_settime (timer_t timerid,                        int flags,                        struct itimerspec *value,                        struct itimerspec *oldvalue);         * */</span>        <span class="token function">timer_settime</span><span class="token punctuation">(</span>msg<span class="token operator">-</span><span class="token operator">></span>mTimerId<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>itime<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>    <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">ifdef</span> __QNX__</span>    <span class="token keyword">void</span> HandlerQueue<span class="token operator">::</span><span class="token function">onTriggered</span><span class="token punctuation">(</span><span class="token keyword">union</span> sigval s<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Message <span class="token operator">*</span>msgObject <span class="token operator">=</span> <span class="token punctuation">(</span>Message <span class="token operator">*</span><span class="token punctuation">)</span>s<span class="token punctuation">.</span>sival_ptr<span class="token punctuation">;</span>        msgObject<span class="token operator">-</span><span class="token operator">></span>_dispatchQueue<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                            <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>msgObject<span class="token operator">-</span><span class="token operator">></span>mTriggeredFunction <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                msgObject<span class="token operator">-</span><span class="token operator">></span><span class="token function">mTriggeredFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        msgObject<span class="token operator">-</span><span class="token operator">></span><span class="token function">mTriggeredFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="一、C-标准实现"><a href="#一、C-标准实现" class="headerlink" title="一、C++标准实现"></a>一、C++标准实现</h1><p>如果不想处理平台差异，且对性能要求没有那么高，可以用c++的一些标准实现</p><p>定时器的主要数据：<br>   1.一个线程变量，保存定时器线程<br>   2.一个互斥锁，配合条件变量使用<br>   3.一个条件变量，结合互斥锁，可以是线程不执行任务时，睡眠一段时间，在退出调用时，可以唤醒线程完成退出<br>   4.定时执行函数，具体的定时执行业务操作<br>   5.间隔时间，定时器间隔一段时间调用定时执行函数<br>   6.一个退出标识，标志是否退出定时线程循环<br>   7.立即执行标识，标识新建状态的定时线程是否立即执行一次任务，而不需等待一个间隔时间才开始执行第一次任务</p><pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;chrono></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;atomic></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;condition_variable></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 定时器类型</span><span class="token comment" spellcheck="true">/*   主要数据：   1.一个线程变量，保存定时器线程   2.一个互斥锁，配合条件变量使用   3.一个条件变量，结合互斥锁，可以是线程不执行任务时，睡眠一段时间，在退出调用时，可以唤醒线程完成退出   4.定时执行函数，具体的定时执行业务操作   5.间隔时间，定时器间隔一段时间调用定时执行函数   6.一个退出标识，标志是否退出定时线程循环   7.立即执行标识，标识新建状态的定时线程是否立即执行一次任务，而不需等待一个间隔时间才开始执行第一次任务*/</span><span class="token keyword">class</span> <span class="token class-name">CTimer</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">F</span><span class="token operator">></span>    <span class="token function">CTimer</span><span class="token punctuation">(</span>F func<span class="token punctuation">)</span>         <span class="token operator">:</span> <span class="token function">m_func</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">CTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 启动函数</span>    <span class="token keyword">void</span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> imsec<span class="token punctuation">,</span> <span class="token keyword">bool</span> bimmediately_run <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> __FUNCTION__ <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>imsec <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> imsec <span class="token operator">==</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 间隔时间为0或默认无效值，直接返回</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        m_bexit<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m_imsec <span class="token operator">=</span> imsec<span class="token punctuation">;</span>        m_bimmediately_run<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>bimmediately_run<span class="token punctuation">)</span><span class="token punctuation">;</span>        m_thread <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">thread</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>CTimer<span class="token operator">::</span>Run<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 结束</span>    <span class="token keyword">void</span> <span class="token function">Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> __FUNCTION__ <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        m_bexit<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m_cond<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 唤醒线程</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>m_thread<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            m_thread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">SetExit</span><span class="token punctuation">(</span><span class="token keyword">bool</span> b_exit<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        m_bexit<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>b_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>m_bimmediately_run<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 立即执行判断</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>m_func<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token function">m_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>m_bexit<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 锁放在花括号内部，减小锁的粒度</span>                std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">locker</span><span class="token punctuation">(</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 如果是被唤醒的，需要判断先条件确定是不是虚假唤醒</span>                <span class="token comment" spellcheck="true">// wait_for是等待第三个参数满足条件，当不满足时，超时后继续往下执行</span>                m_cond<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>locker<span class="token punctuation">,</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span>m_imsec<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> m_bexit<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>m_bexit<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 再校验下退出标识</span>            <span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>m_func<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token function">m_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span> <span class="token comment" spellcheck="true">// 私有数据部分</span>    std<span class="token operator">::</span>atomic_bool m_bexit <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>atomic_bool m_bimmediately_run <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 是否立即执行</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> m_imsec <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 间隔时间</span>    std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> m_func<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 执行函数</span>    std<span class="token operator">::</span>thread m_thread<span class="token punctuation">;</span>    std<span class="token operator">::</span>mutex m_mutex<span class="token punctuation">;</span>    std<span class="token operator">::</span>condition_variable m_cond<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> g_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 定时执行函数</span><span class="token keyword">void</span> <span class="token function">OnTimeFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> __FUNCTION__ <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">++</span>g_index <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 测试自己写的定时器</span><span class="token keyword">void</span> <span class="token function">Test_Timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>CTimer<span class="token operator">></span> ptr_timer <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>CTimer<span class="token operator">></span><span class="token punctuation">(</span>OnTimeFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr_timer <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ptr_timer<span class="token operator">-</span><span class="token operator">></span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ptr_timer<span class="token operator">-</span><span class="token operator">></span><span class="token function">Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 离开作用已记得停止定时器</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 程序入口</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">Test_Timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"getchar"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Reference:<br><a href="http://www.qnx.com/developers/docs/qnxcar2/index.jsp?topic=%2Fcom.qnx.doc.neutrino.getting_started%2Ftopic%2Fs1_timer_General_notification.html" target="_blank" rel="noopener">How to fill in the struct sigevent</a></p><p><a href="https://blog.csdn.net/chenshiming1995/article/details/111028126" target="_blank" rel="noopener">QNX系列：三、时钟与定时器</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android/Java 线程池笔记</title>
      <link href="/2022/10/08/android-thredpool/"/>
      <url>/2022/10/08/android-thredpool/</url>
      
        <content type="html"><![CDATA[<h1 id="一、为何要使用线程池"><a href="#一、为何要使用线程池" class="headerlink" title="一、为何要使用线程池"></a>一、为何要使用线程池</h1><p>在Java中，要使用多线程，除了使用new Thread()之外，还可以使用线程池ExecutorService。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用Thread</span>Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用线程池</span>ExecutorService es <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>es<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>线程池主要解决了两个问题：</p><ol><li>频繁创建销毁线程的开销</li><li>任务的管理</li></ol><p>在异步任务比较多时，创建、销毁线程会占用很多系统资源；这时候，使用线程池，就可以实现线程的复用，让人专注于任务的实现，而不是管理线程。</p><h1 id="二、线程池简介"><a href="#二、线程池简介" class="headerlink" title="二、线程池简介"></a>二、线程池简介</h1><h2 id="1-什么是线程池"><a href="#1-什么是线程池" class="headerlink" title="1. 什么是线程池"></a>1. 什么是线程池</h2><p>线程池（本文特指ThreadPoolExecutor类）顾名思义，就是一个装了线程的池子。线程池创建和管理若干线程，在需要使用的时候可以直接从线程池中取出来使用，在任务结束之后闲置等待复用，或者销毁。<br>线程池中的线程分为两种：核心线程和普通线程。核心线程即线程池中长期存活的线程，即使闲置下来也不会被销毁，需要使用的时候可以直接拿来用。而普通线程则有一定的寿命，如果闲置时间超过寿命，则这个线程就会被销毁。</p><p>查看ThreadPoolExecutor类的其中一个典型的构造方法：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                              <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                              <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                              TimeUnit unit<span class="token punctuation">,</span>                              BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> maximumPoolSize<span class="token punctuation">,</span> keepAliveTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> workQueue<span class="token punctuation">,</span>             Executors<span class="token punctuation">.</span><span class="token function">defaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> defaultHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>线程池的具体行为和几个参数有关：</p><ul><li>核心数 corePoolSize<br>线程池中核心线程的数量。</li><li>最大容量 maximumPoolSize<br>线程池最大允许保留多少线程。</li><li>超时时间 keepAliveTime<br>线程池中普通线程的存活时间。</li></ul><h2 id="2-线程池的使用"><a href="#2-线程池的使用" class="headerlink" title="2. 线程池的使用"></a>2. 线程池的使用</h2><p>线程池的一般使用步骤如下：</p><p>使用Executors中的工厂方法来获取ExecutorService实例；<br>使用ExecutorService的execute(runnable)或者submit(runnable)方法来添加任务。</p><pre class="line-numbers language-java"><code class="language-java">ExecutorService es <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    es<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String response <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HttpUtil</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"http://littlefogcat.top"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-线程池的分类"><a href="#3-线程池的分类" class="headerlink" title="3. 线程池的分类"></a>3. 线程池的分类</h2><p>在Executors工厂类中提供了多种线程池，典型的有以下四种：</p><h3 id="1-SingleThreadExecutor-单线程线程池"><a href="#1-SingleThreadExecutor-单线程线程池" class="headerlink" title="1. SingleThreadExecutor 单线程线程池"></a>1. SingleThreadExecutor 单线程线程池</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>            <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>                     0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                     <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>核心线程数为1，最大线程数为1，也就是说SingleThreadExecutor这个线程池中的线程数固定为1。使用场景：当多个任务都需要访问同一个资源的时候。</p><h3 id="2-FixedThreadPool-固定容量线程池"><a href="#2-FixedThreadPool-固定容量线程池" class="headerlink" title="2. FixedThreadPool 固定容量线程池"></a>2. FixedThreadPool 固定容量线程池</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>                                      0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                      <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>核心线程数为n，最大线程数为n。使用场景：明确同时执行任务数量时。</p><h3 id="3-CachedThreadPool-缓存线程池"><a href="#3-CachedThreadPool-缓存线程池" class="headerlink" title="3. CachedThreadPool 缓存线程池"></a>3. CachedThreadPool 缓存线程池</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span>                                      60L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                                      <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>核心线程数为0，最大线程数无上限，线程超时时间60秒。使用场景：处理大量耗时较短的任务。</p><h3 id="4-ScheduledThreadPool-定时线程池"><a href="#4-ScheduledThreadPool-定时线程池" class="headerlink" title="4. ScheduledThreadPool 定时线程池"></a>4. ScheduledThreadPool 定时线程池</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ScheduledExecutorService <span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*    public ScheduledThreadPoolExecutor(int corePoolSize) {        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,              new DelayedWorkQueue());    }*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>核心线程数自定，最大线程数无上限。使用场景：处理延时任务。</p><p>可以看到，这四个方法都返回了一个ThreadPoolExecutor对象（ScheduledThreadPoolExecutor是其子类），仅仅是其中的参数略有不同。所以接下来就对ThreadPoolExecutor类进行解析。</p><h2 id="4-ExecutorService-submit-与Executor-execute-两个方法的相同与不同之处"><a href="#4-ExecutorService-submit-与Executor-execute-两个方法的相同与不同之处" class="headerlink" title="4. ExecutorService.submit()与Executor.execute() 两个方法的相同与不同之处"></a>4. ExecutorService.submit()与Executor.execute() 两个方法的相同与不同之处</h2><h3 id="相同之处："><a href="#相同之处：" class="headerlink" title="相同之处："></a>相同之处：</h3><p>Both submit() and execute() methods are used to submit a task to Executor framework for asynchronous execution.<br>submit和execute方法均可以想线程池中提交一个任务，让线程池来异步执行这个任务<br>Both submit() and execute() can accept a Runnable task.<br>两个方法均可以接受Runnable类型的任务<br>You can access submit() and execute() from the ExecutorService interface because it also extends the Executor interface which declares the execute() method.<br>从ExecutorService接口中均可以调用submit和execute方法，但是submit方法是在ExecutorService接口中定义的，而execute方法是在Executor接口中定义的</p><h3 id="不同之处："><a href="#不同之处：" class="headerlink" title="不同之处："></a>不同之处：</h3><p>The submit() can accept both Runnable and Callable task but execute() can only accept the Runnable task.<br>submit方法既能接受有返回结果Callable类型和没有返回结果的Runnable类型，而execute方法只能结构没有返回结果的Runnable类型<br>The submit() method is declared in ExecutorService interface while execute() method is declared in the Executor interface.<br>submit方法是定义在ExecutorService接口中的，而execute方法是定义在Executor接口中的<br>The return type of submit() method is a Future object but return type of execute() method is void.<br>submit方法的返回值是一个Future，而execute方法的返回值是void<br>对于异常的处理<br>使用submit方式提交的任务若在执行的过程中抛出了异常的话，异常信息会被吃掉（在控制台中看不到），需要通过Future.get方法来获取这个异常；使用execute方式提交的任务若在执行的过程中出现异常的话，异常信息会被打印到控制台</p><p>参考:<br><a href="https://zhuanlan.zhihu.com/p/143484740" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/143484740</a><br><a href="https://www.imangodoc.com/178483.html" target="_blank" rel="noopener">https://www.imangodoc.com/178483.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL list容器 .size()返回数值错误</title>
      <link href="/2020/08/07/stlsizeerror/"/>
      <url>/2020/08/07/stlsizeerror/</url>
      
        <content type="html"><![CDATA[<p>前两天写缓存代码时，遇见了一个我认为是STL的bug，如图所示，t2_clean是我定义的一个std::list对象，通过IDE我们可以看到此时该容器中有两个节点，分别对应的下标是0和1，此时我们调用.size（）方法，理应获得的值是2，但这里获得的值是-1，通过多次调试，每次返回值是不同的，但总之是，.size（）返回的值和容器中真实的节点个数不匹配。<br><img src="https://pic.downk.cc/item/5f2ccafd14195aa594c30ea0.png" alt></p><p>通过一系列的Debug，找到了问题，其原因是splice函数，在我的项目代码中写了这样的一个语句，</p><pre><code>t2.splice(t2.begin(), t2_clean, it2-&gt;list_ptr);</code></pre><p>其中，t2和t2_clean一样也是std::list容器对象，splice函数的功能是将某个list对象（t2_clean）节点移动至另一个list对象（t2）的指定位置，其三个参数的意义分别是：</p><ol><li>指向调用splice函数list对象中某个节点的迭代器（t2.begin（）），将另一个对象插入到该迭代器前一个位置，在本语句中表示会将t2_clean对象的某个元素插入到t2的头节点前的一个位置。</li><li>和3 表示想要移动的list对象t2_clean）以及指向该对象某个元素的迭代器（it2-&gt;list_ptr）</li></ol><p>splice函数如果遇见t2_clean是空的，此时继续执行splice函数会怎样？没错，该意外操作并不会报错，需要程序员自己控制该意外情况不发生，继续执行会导致t2的节点+1以及t2_clean的节点数目-1，但并不会真的有节点插入t2,此时对t2和t2_clean调用.size（）方法会发现，t2的size比实际它所存储的节点数目多1，而t2_clean的size比实际它所存储的节点数目少1。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将CAJ文档转换成带书签的PDF</title>
      <link href="/2020/08/05/cajtopdf/"/>
      <url>/2020/08/05/cajtopdf/</url>
      
        <content type="html"><![CDATA[<p>刚入门的科研工作者经常会阅读知网上的硕博论文，尤其是文科的童鞋们，理工科也可以从优秀的硕博中了解本行业的基础知识。<br>但是知网的CAJ非常难用（就是LJ），pdf版本下载下来没有书签，故在此提供一个简单的方案，非常easy和快速，熟练的话也就一两分钟。</p><p>首先，你得有一个女票让你帮她给她想看的论文加标签，现在开始<br><strong>第一步</strong>，通过知网下载对应论文的pdf版本，部分论文可能没有pdf的下载选项，网上大多数方法是采用虚拟打印，但这样的话，对应的文字是无法选中的，需要用OCR去识别，且识别率不高，这里建议下载对应油猴插件，可以很easy解决该问题，不多赘述。<br><img src="https://pic.downk.cc/item/5f2ab15d14195aa594014f4d.png" alt></p><p><strong>第二步</strong>，我们通过 <strong>分章下载</strong> 按钮获得对应文献的参考目录，然后将其复制到word中，记得粘贴的时候不要将格式粘贴进去，选择只保留文本<br><img src="https://pic.downk.cc/item/5f2ab29a14195aa594020bbd.png" alt><br><img src="https://pic.downk.cc/item/5f2ab29a14195aa594020bc4.png" alt></p><p><strong>第三步</strong>， 通过“开发”进入“Visual Basic”（word中的快捷键是alt + F11），右键thisDocument，“导入文件”，导入“知网书签.bas”，点击运行，确认即可。<br><img src="https://pic.downk.cc/item/5f2ab42a14195aa59402f2d3.png" alt><br><img src="https://pic.downk.cc/item/5f2ab42a14195aa59402f2d5.png" alt><br><img src="https://pic.downk.cc/item/5f2ab51d14195aa594037885.png" alt></p><p><strong>第四步</strong>， 运行 FreePic2Pdf.exe，选择右下角的更改pdf ， 切换至从PDF取书签标签页，选取对应的 PDF 文件，并进行书签提取<br><img src="https://pic.downk.cc/item/5f2ab72514195aa594049018.png" alt><br><img src="https://pic.downk.cc/item/5f2ab72514195aa59404901a.png" alt></p><p><strong>第五步</strong>，切换至 往PDF挂书签标签页，点击编辑书签，清空编辑框，将第二步生成的书签文本复制到此，并保存。在往PDF挂书签标签页点击开始进行挂书签，将原有 PDF 转换成带有书签的 PDF。注意此步骤需要将 PDF 文件关闭，避免读取出错。</p><p><img src="https://pic.downk.cc/item/5f2ab86d14195aa59405434f.png" alt><br><img src="https://pic.downk.cc/item/5f2ab86d14195aa594054351.png" alt><br><img src="https://pic.downk.cc/item/5f2ab86d14195aa594054355.png" alt></p><p><strong>第六步</strong>，完成，可以向女票交差了<br><img src="https://pic.downk.cc/item/5f2ab86d14195aa594054357.png" alt></p><h3 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h3><p>本文使用到的所有工具<br><a href="https://drive.google.com/file/d/1gBbdXu7kTb9caMpuGheFYFPdSMLVdXpV/view?usp=sharing" target="_blank" rel="noopener">谷歌云</a><br><strong>百度云</strong>：链接：<a href="https://pan.baidu.com/s/1DEOtj1jIup3oULIVJEpInw" target="_blank" rel="noopener">https://pan.baidu.com/s/1DEOtj1jIup3oULIVJEpInw</a><br>提取码：afwb</p><p>本文方法转自<br><a href="http://blog.sina.com.cn/s/blog_d1ebd8ae0102wejz.html" target="_blank" rel="noopener">将CAJ文件转换为带书签的pdf的方法</a><br>和<a href="https://shenxiaohai.me/2018/03/15/caj-to-pdf/" target="_blank" rel="noopener">如何将 CAJ 文档转换成带书签的 PDF</a><br>这两个博客分别遇到内容被隐藏以及下载链接失效的问题，故在此分享一下该方法给年轻的科研工作者</p>]]></content>
      
      
      <categories>
          
          <category> 科研工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh断开后，程序如何继续在服务器后台运行</title>
      <link href="/2019/12/07/how-to-run-background/"/>
      <url>/2019/12/07/how-to-run-background/</url>
      
        <content type="html"><![CDATA[<p>这两天在服务器上跑程序，因为实验室有人在服务器上跑了Gnome，我只能用ssh连接在上面跑程序。因为程序跑的时间比较久，中间ssh在闲置一段时间后会自动断开（ssh没有心跳检测），ssh断开后我们在服务器上跑的程序也就会停止，这就产生了困扰。</p><p>简单在Google搜了下，解决方法有以下三种</p><ol><li><strong>nohup指令</strong></li><li><strong>screen指令</strong></li><li><strong>byobu指令</strong></li></ol><p>其中，nohun指令是大多数Linux发行版自带的，不用刻意安装，screen会在当前命令行界面再开一个窗口，我们可以在任何命令行界面打开这个窗口，这样，当前命令行关闭后，我们运行的程序也就不会被动关闭。byobu是screen的升级版（网上是这样说的）</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>通过对几个命令的实验，我感觉<strong>byobu是最好用</strong>也是最方便的，下面简单介绍一下。</li></ul><p>首先，我们要安装byobu，红帽系用yum安装，debian用apt get，因为我的服务器是ubuntu，故我采用的命令是</p><pre><code>sudo apt install byobu</code></pre><p>安装好byobu后，我们在命令行输入就能打开byobu，如图<br><img src="1.jpg" alt></p><h3 id="byobu的基本简单操作"><a href="#byobu的基本简单操作" class="headerlink" title="byobu的基本简单操作"></a>byobu的基本简单操作</h3><table><thead><tr><th>按键</th><th align="center">说明</th></tr></thead><tbody><tr><td>F2</td><td align="center">新建窗口</td></tr><tr><td>F3</td><td align="center">移动到前一个窗口</td></tr><tr><td>F6</td><td align="center">退出byobu窗口</td></tr><tr><td>F9</td><td align="center">打开byobu菜单，查看帮助信息的配置信息</td></tr><tr><td>Ctrl+D</td><td align="center">关闭当前窗口</td></tr></tbody></table><p>如果我们想要一登陆就显示byobu界面的话，可以使用命令</p><pre><code>byobu-enable</code></pre><p>关闭使用的命令是</p><pre><code>byobu-disable</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 服务器 </tag>
            
            <tag> shell命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小站伊始</title>
      <link href="/2019/12/06/xiao-zhan-yi-shi/"/>
      <url>/2019/12/06/xiao-zhan-yi-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="建站之初"><a href="#建站之初" class="headerlink" title="建站之初"></a>建站之初</h1><p>因为想要记录一些自己学过的东西和折腾的经历，故学着大佬们利用GitHub Pages来搭建一个自己的小博客。起初也是因为我通过别人的博客获得了一些帮助（如通过<a href="http://cighao.com" target="_blank" rel="noopener">陈浩的博客</a>获取了一些在disksim和flash sim使用上的帮助）故也希望自己折腾的一些经历能够帮助别人。</p><h2 id="博客计划分享的内容"><a href="#博客计划分享的内容" class="headerlink" title="博客计划分享的内容"></a>博客计划分享的内容</h2><ul><li><p><strong>研究内容</strong></p><p>我目前正在读CS体系结构的master’s degree，研究方向是NAND Flash存储系统和 KV存储系统优化，可能会分享一些这个研究方向的内容以及开源代码，比如MQsim的代码，我的部分实验时基于这个SSD模拟器做的，其实CMU 2018年发布在Fast上的论文，并在GitHub上开源，可以说是目前最先进的SSD模拟器，其代码量相对较大，且参考资料不多，中文资料截止目前网上还一点没有，我可能会在之后分享一些相关资料。其它的比如 Leveldb，ms ssdmodel等，网上已经有不少相关资料，我也可能会分享一些自己的理解。</p></li><li><p><strong>算法，数据结构，Coding中的问题等</strong></p><p>在写代码的过程中，经常会遇见一些好的idea，有趣的算法或者debug时遇见一些难解决的问等。我可能会记录下来，一是为了帮助自己整理和记忆，其次是希望能帮到其他遇见这个问题的人。</p></li><li><p><strong>数码产品的折腾，NAS，路由等</strong></p><p>我本身喜欢捣鼓一些电子产品，一个是能够改善某些使用体验，使其个性化，其次是我也享受实现功能（折腾）的过程，我目前个人买了一台群晖DS918+，可能会分享Nas,路由，安卓，树莓派，服务器以及一些智能家居的折腾经历。</p></li></ul><p><img src="1.jpg" alt></p><h2 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h2><p>本博客使用的是Hexo框架，并采用<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">hexo-theme-matery主题</a>，目前搭建在GitHub Pages上面，原本计划搭建在国内的平台上，如Coding和码云，不过都有限制，Coding有单个仓库不大于100MB的限制，码云有不能修改域名的限制，故最后还是选择GitHub了</p><div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=4970212&auto=1&height=66"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
